#
# CMake script to split a header-only library into .h and .c/.cpp files
# based on a specific preprocessor guard (e.g., LIBACQUIRE_IMPLEMENTATION).
#

# Helper macro to check if a directive line starts the implementation block.
macro(_sh_check_is_implementation_directive _directive_command _directive_args _impl_macro_name _out_is_impl_start_var)
    set(${_out_is_impl_start_var} FALSE)

    if ("${_directive_command}" STREQUAL "ifdef")
        if ("${_directive_args}" STREQUAL "${_impl_macro_name}")
            set(${_out_is_impl_start_var} TRUE)
            return()
        endif ()
    elseif ("${_directive_command}" STREQUAL "if")
        set(_found_match FALSE)
        set(_search_args_remaining "${_directive_args}") # String to search in, gets shorter

        while (NOT _found_match AND _search_args_remaining) # Loop as long as there's string to search
            string(FIND "${_search_args_remaining}" "defined" _defined_keyword_idx_in_remaining)

            if (_defined_keyword_idx_in_remaining EQUAL -1)
                break() # No more "defined" occurrences
            endif ()

            set(_scan_idx_local ${_defined_keyword_idx_in_remaining})
            math(EXPR _scan_idx_local "${_scan_idx_local} + 7") # Move past "defined"

            string(LENGTH "${_search_args_remaining}" _search_args_remaining_len)
            set(_current_parse_failed FALSE) # Flag for failure in current defined() attempt

            # --- Start parsing "defined ( MACRO )" structure ---
            # Skip whitespace after "defined"
            while (_scan_idx_local LESS _search_args_remaining_len)
                string(SUBSTRING "${_search_args_remaining}" ${_scan_idx_local} 1 _s_char)
                if (NOT (_s_char STREQUAL " " OR _s_char STREQUAL "\t"))
                    break()
                endif ()
                math(EXPR _scan_idx_local "${_scan_idx_local} + 1")
            endwhile ()

            if (_scan_idx_local GREATER_EQUAL _search_args_remaining_len)
                set(_current_parse_failed TRUE)
            endif ()

            # Expect '('
            if (NOT _current_parse_failed)
                string(SUBSTRING "${_search_args_remaining}" ${_scan_idx_local} 1 _s_char)
                if (NOT _s_char STREQUAL "(")
                    set(_current_parse_failed TRUE)
                else ()
                    math(EXPR _scan_idx_local "${_scan_idx_local} + 1") # Move past '('
                endif ()
            endif ()

            # Skip whitespace after '('
            if (NOT _current_parse_failed)
                while (_scan_idx_local LESS _search_args_remaining_len)
                    string(SUBSTRING "${_search_args_remaining}" ${_scan_idx_local} 1 _s_char)
                    if (NOT (_s_char STREQUAL " " OR _s_char STREQUAL "\t"))
                        break()
                    endif ()
                    math(EXPR _scan_idx_local "${_scan_idx_local} + 1")
                endwhile ()
                if (_scan_idx_local GREATER_EQUAL _search_args_remaining_len)
                    set(_current_parse_failed TRUE)
                endif ()
            endif ()

            # Expect implementation_macro_name
            if (NOT _current_parse_failed)
                string(LENGTH "${_impl_macro_name}" _impl_macro_name_len)
                if (_impl_macro_name_len EQUAL 0)
                    set(_current_parse_failed TRUE) # Invalid macro name
                else ()
                    math(EXPR _expected_token_end_local "${_scan_idx_local} + ${_impl_macro_name_len}")
                    if (_expected_token_end_local GREATER _search_args_remaining_len)
                        set(_current_parse_failed TRUE) # Not enough space for macro
                    else ()
                        string(SUBSTRING "${_search_args_remaining}" ${_scan_idx_local} ${_impl_macro_name_len} _token_candidate)
                        if (NOT _token_candidate STREQUAL "${_impl_macro_name}")
                            set(_current_parse_failed TRUE)
                        else ()
                            math(EXPR _scan_idx_local "${_scan_idx_local} + ${_impl_macro_name_len}") # Move past token
                        endif ()
                    endif ()
                endif ()
            endif ()

            # Skip whitespace after token
            if (NOT _current_parse_failed)
                while (_scan_idx_local LESS _search_args_remaining_len)
                    string(SUBSTRING "${_search_args_remaining}" ${_scan_idx_local} 1 _s_char)
                    if (NOT (_s_char STREQUAL " " OR _s_char STREQUAL "\t"))
                        break()
                    endif ()
                    math(EXPR _scan_idx_local "${_scan_idx_local} + 1")
                endwhile ()
                if (_scan_idx_local GREATER_EQUAL _search_args_remaining_len) # Might be an issue if ')' is mandatory
                    set(_current_parse_failed TRUE)
                endif ()
            endif ()

            # Expect ')'
            if (NOT _current_parse_failed)
                string(SUBSTRING "${_search_args_remaining}" ${_scan_idx_local} 1 _s_char)
                if (NOT _s_char STREQUAL ")")
                    set(_current_parse_failed TRUE) # Pattern broken
                else()
                    set(_found_match TRUE) # Successfully found "defined ( IMPL_MACRO_NAME )"
                endif ()
            endif ()
            # --- End parsing "defined ( MACRO )" structure ---

            if (NOT _found_match) # If current "defined" did not result in a match
                # Advance search to after the 'd' of the current "defined" keyword
                math(EXPR _next_search_start_in_remaining "${_defined_keyword_idx_in_remaining} + 1")
                if (_next_search_start_in_remaining LESS _search_args_remaining_len)
                    string(SUBSTRING "${_search_args_remaining}" ${_next_search_start_in_remaining} -1 _search_args_remaining_next_iter)
                    set(_search_args_remaining "${_search_args_remaining_next_iter}")
                else ()
                    set(_search_args_remaining "") # No more string left to search
                endif ()
            endif () # (else, if _found_match, loop will terminate)
        endwhile () # End while searching for "defined"

        if (_found_match)
            set(${_out_is_impl_start_var} TRUE)
        endif ()
    endif ()
endmacro()


function(SPLIT_HEADER_ONLY INPUT_HEADER_FILE OUTPUT_HEADER_FILE OUTPUT_SOURCE_FILE IMPL_MACRO_NAME)
    message(STATUS "Splitting header: ${INPUT_HEADER_FILE}")
    message(STATUS "  Output header: ${OUTPUT_HEADER_FILE}")
    message(STATUS "  Output source: ${OUTPUT_SOURCE_FILE}")
    message(STATUS "  Implementation macro: ${IMPL_MACRO_NAME}")

    if (NOT EXISTS "${INPUT_HEADER_FILE}")
        message(FATAL_ERROR "Input header file not found: ${INPUT_HEADER_FILE}")
        return()
    endif ()

    file(READ "${INPUT_HEADER_FILE}" _content)
    string(LENGTH "${_content}" _content_len)

    set(_output_h_content "")
    set(_output_cxx_content "")

    get_filename_component(_output_header_fname "${OUTPUT_HEADER_FILE}" NAME)
    set(_output_cxx_content "#include \"${_output_header_fname}\"\n\n")

    set(_current_target "header")
    set(_char_idx 0)
    set(_line_start_idx 0)

    set(_in_c_comment FALSE)
    set(_in_cpp_comment FALSE)
    set(_in_string FALSE)
    set(_in_char FALSE)

    set(_pp_level 0)
    set(_impl_block_pp_level -1)

    set(_skip_default_char_idx_increment FALSE)

    while (_char_idx LESS _content_len)
        set(_skip_default_char_idx_increment FALSE)
        set(_char_consumed_this_iteration 1)

        string(SUBSTRING "${_content}" ${_char_idx} 1 _cur_char)
        set(_next_char "")
        math(EXPR _char_idx_plus_1 "${_char_idx} + 1")
        if (_char_idx_plus_1 LESS _content_len)
            string(SUBSTRING "${_content}" ${_char_idx_plus_1} 1 _next_char)
        endif ()

        if (_in_c_comment)
            if (_cur_char STREQUAL "*" AND _next_char STREQUAL "/")
                if (_current_target STREQUAL "source")
                    string(APPEND _output_cxx_content "*/")
                else ()
                    string(APPEND _output_h_content "*/")
                endif ()
                set(_in_c_comment FALSE)
                set(_char_consumed_this_iteration 2)
            else ()
                if (_current_target STREQUAL "source")
                    string(APPEND _output_cxx_content "${_cur_char}")
                else ()
                    string(APPEND _output_h_content "${_cur_char}")
                endif ()
            endif ()
        elseif (_in_cpp_comment)
            if (_cur_char STREQUAL "\n")
                if (_current_target STREQUAL "source")
                    string(APPEND _output_cxx_content "\n")
                else ()
                    string(APPEND _output_h_content "\n")
                endif ()
                set(_in_cpp_comment FALSE)
                math(EXPR _line_start_idx "${_char_idx} + 1")
            else ()
                if (_current_target STREQUAL "source")
                    string(APPEND _output_cxx_content "${_cur_char}")
                else ()
                    string(APPEND _output_h_content "${_cur_char}")
                endif ()
            endif ()
        elseif (_in_string)
            if (_cur_char STREQUAL "\\")
                if (_char_idx_plus_1 LESS _content_len) # Check if _next_char is valid
                    if (_current_target STREQUAL "source")
                        string(APPEND _output_cxx_content "\\${_next_char}")
                    else ()
                        string(APPEND _output_h_content "\\${_next_char}")
                    endif ()
                    set(_char_consumed_this_iteration 2)
                else () # Backslash at end of file
                    if (_current_target STREQUAL "source")
                        string(APPEND _output_cxx_content "\\")
                    else ()
                        string(APPEND _output_h_content "\\")
                    endif ()
                endif()
            elseif (_cur_char STREQUAL "\"")
                if (_current_target STREQUAL "source")
                    string(APPEND _output_cxx_content "\"")
                else ()
                    string(APPEND _output_h_content "\"")
                endif ()
                set(_in_string FALSE)
            else ()
                if (_current_target STREQUAL "source")
                    string(APPEND _output_cxx_content "${_cur_char}")
                else ()
                    string(APPEND _output_h_content "${_cur_char}")
                endif ()
            endif ()
        elseif (_in_char)
            if (_cur_char STREQUAL "\\")
                if (_char_idx_plus_1 LESS _content_len) # Check if _next_char is valid
                    if (_current_target STREQUAL "source")
                        string(APPEND _output_cxx_content "\\${_next_char}")
                    else ()
                        string(APPEND _output_h_content "\\${_next_char}")
                    endif ()
                    set(_char_consumed_this_iteration 2)
                else () # Backslash at end of file
                    if (_current_target STREQUAL "source")
                        string(APPEND _output_cxx_content "\\")
                    else ()
                        string(APPEND _output_h_content "\\")
                    endif ()
                endif()
            elseif (_cur_char STREQUAL "'")
                if (_current_target STREQUAL "source")
                    string(APPEND _output_cxx_content "'")
                else ()
                    string(APPEND _output_h_content "'")
                endif ()
                set(_in_char FALSE)
            else ()
                if (_current_target STREQUAL "source")
                    string(APPEND _output_cxx_content "${_cur_char}")
                else ()
                    string(APPEND _output_h_content "${_cur_char}")
                endif ()
            endif ()
        else () # Not in a comment, string, or char literal
            if (_cur_char STREQUAL "/" AND _next_char STREQUAL "*")
                if (_current_target STREQUAL "source")
                    string(APPEND _output_cxx_content "/*")
                else ()
                    string(APPEND _output_h_content "/*")
                endif ()
                set(_in_c_comment TRUE)
                set(_char_consumed_this_iteration 2)
            elseif (_cur_char STREQUAL "/" AND _next_char STREQUAL "/")
                if (_current_target STREQUAL "source")
                    string(APPEND _output_cxx_content "//")
                else ()
                    string(APPEND _output_h_content "//")
                endif ()
                set(_in_cpp_comment TRUE)
                set(_char_consumed_this_iteration 2)
            elseif (_cur_char STREQUAL "\"")
                if (_current_target STREQUAL "source")
                    string(APPEND _output_cxx_content "\"")
                else ()
                    string(APPEND _output_h_content "\"")
                endif ()
                set(_in_string TRUE)
            elseif (_cur_char STREQUAL "'")
                if (_current_target STREQUAL "source")
                    string(APPEND _output_cxx_content "'")
                else ()
                    string(APPEND _output_h_content "'")
                endif ()
                set(_in_char TRUE)
            elseif (_cur_char STREQUAL "#")
                set(_is_directive_on_line TRUE)
                set(_ws_check_idx ${_line_start_idx})
                while (_ws_check_idx LESS _char_idx)
                    string(SUBSTRING "${_content}" ${_ws_check_idx} 1 _ws_char)
                    if (NOT (_ws_char STREQUAL " " OR _ws_char STREQUAL "\t" OR _ws_char STREQUAL "\v" OR _ws_char STREQUAL "\f"))
                        set(_is_directive_on_line FALSE)
                        break()
                    endif ()
                    math(EXPR _ws_check_idx "${_ws_check_idx} + 1")
                endwhile ()

                if (_is_directive_on_line)
                    set(_directive_full_raw_line "")
                    set(_directive_scan_idx ${_char_idx})
                    set(_keep_collecting_directive TRUE)
                    while (${_keep_collecting_directive} AND ${_directive_scan_idx} LESS _content_len)
                        string(SUBSTRING "${_content}" ${_directive_scan_idx} 1 _d_scan_char)
                        string(APPEND _directive_full_raw_line "${_d_scan_char}")
                        if (_d_scan_char STREQUAL "\\")
                            math(EXPR _peek_after_slash_idx "${_directive_scan_idx} + 1")
                            if (${_peek_after_slash_idx} LESS _content_len)
                                string(SUBSTRING "${_content}" ${_peek_after_slash_idx} 1 _char_after_slash)
                                if (_char_after_slash STREQUAL "\n")
                                    string(APPEND _directive_full_raw_line "\n")
                                    math(EXPR _directive_scan_idx "${_directive_scan_idx} + 1")
                                    math(EXPR _line_start_idx "${_directive_scan_idx} + 1")
                                elseif (_char_after_slash STREQUAL "\r")
                                    math(EXPR _peek_after_cr_idx "${_directive_scan_idx} + 2")
                                    if (${_peek_after_cr_idx} LESS _content_len)
                                        string(SUBSTRING "${_content}" ${_peek_after_cr_idx} 1 _char_after_cr)
                                        if (_char_after_cr STREQUAL "\n")
                                            string(APPEND _directive_full_raw_line "\r\n")
                                            math(EXPR _directive_scan_idx "${_directive_scan_idx} + 2")
                                            math(EXPR _line_start_idx "${_directive_scan_idx} + 1")
                                        endif ()
                                    endif ()
                                endif ()
                            else () # Backslash at end of file
                                set(_keep_collecting_directive FALSE)
                            endif ()
                        elseif (_d_scan_char STREQUAL "\n")
                            set(_keep_collecting_directive FALSE)
                            math(EXPR _line_start_idx "${_directive_scan_idx} + 1")
                        elseif (_d_scan_char STREQUAL "\r")
                            math(EXPR _peek_after_cr_idx "${_directive_scan_idx} + 1")
                            if (${_peek_after_cr_idx} LESS _content_len)
                                string(SUBSTRING "${_content}" ${_peek_after_cr_idx} 1 _char_after_cr)
                                if (NOT _char_after_cr STREQUAL "\n") # If \r\n, the \n case handles it
                                    set(_keep_collecting_directive FALSE)
                                    math(EXPR _line_start_idx "${_directive_scan_idx} + 1")
                                endif ()
                            else () # \r at EOF
                                set(_keep_collecting_directive FALSE)
                                math(EXPR _line_start_idx "${_directive_scan_idx} + 1")
                            endif ()
                        endif ()
                        math(EXPR _directive_scan_idx "${_directive_scan_idx} + 1")
                    endwhile ()

                    if (_directive_full_raw_line)
                        string(SUBSTRING "${_directive_full_raw_line}" 1 -1 _directive_body_with_ending_ws)
                    else()
                        set(_directive_body_with_ending_ws "")
                    endif()

                    set(_directive_body_for_parse "${_directive_body_with_ending_ws}")
                    string(LENGTH "${_directive_body_for_parse}" _len_for_trim)
                    set(_trimmed_this_pass TRUE)
                    while(_trimmed_this_pass AND _len_for_trim GREATER 0)
                        set(_trimmed_this_pass FALSE)
                        # Safe to use -1 1 due to _len_for_trim GREATER 0 guard
                        string(SUBSTRING "${_directive_body_for_parse}" 0 1 _last_char_val)
                        if (_last_char_val STREQUAL "\n" OR _last_char_val STREQUAL "\r")
                            math(EXPR _len_for_trim "${_len_for_trim} - 1")
                            if (_len_for_trim LESS 0) # Should not happen if logic is right
                                set(_len_for_trim 0)
                            endif()
                            string(SUBSTRING "${_directive_body_for_parse}" 0 ${_len_for_trim} _directive_body_for_parse)
                            set(_trimmed_this_pass TRUE)
                            string(LENGTH "${_directive_body_for_parse}" _len_for_trim) # Re-evaluate length
                        endif()
                    endwhile()

                    set(_temp_body_trimmed "${_directive_body_for_parse}")
                    set(_final_body_for_parse "")
                    string(LENGTH "${_temp_body_trimmed}" _body_parse_len)
                    set(_body_parse_idx 0)
                    set(_non_ws_found_in_body FALSE)
                    while (_body_parse_idx LESS _body_parse_len)
                        string(SUBSTRING "${_temp_body_trimmed}" ${_body_parse_idx} 1 _b_p_char)
                        if (NOT _non_ws_found_in_body AND (_b_p_char STREQUAL " " OR _b_p_char STREQUAL "\t"))
                            # skip leading whitespace
                        else ()
                            set(_non_ws_found_in_body TRUE)
                            string(APPEND _final_body_for_parse "${_b_p_char}")
                        endif ()
                        math(EXPR _body_parse_idx "${_body_parse_idx} + 1")
                    endwhile ()

                    set(_directive_command "")
                    set(_directive_args "")
                    string(FIND "${_final_body_for_parse}" " " _space_idx)
                    string(FIND "${_final_body_for_parse}" "\t" _tab_idx)
                    set(_split_idx -1)

                    if (_space_idx EQUAL -1 AND _tab_idx EQUAL -1)
                        set(_directive_command "${_final_body_for_parse}")
                    elseif (_space_idx EQUAL -1)
                        set(_split_idx ${_tab_idx})
                    elseif (_tab_idx EQUAL -1)
                        set(_split_idx ${_space_idx})
                    else ()
                        if (_space_idx LESS _tab_idx)
                            set(_split_idx ${_space_idx})
                        else ()
                            set(_split_idx ${_tab_idx})
                        endif ()
                    endif ()

                    if (NOT _split_idx EQUAL -1)
                        string(SUBSTRING "${_final_body_for_parse}" 0 ${_split_idx} _directive_command)
                        math(EXPR _args_start_idx_raw "${_split_idx} + 1")
                        string(SUBSTRING "${_final_body_for_parse}" ${_args_start_idx_raw} -1 _directive_args_raw)

                        # Trim leading whitespace from args
                        set(_temp_args_trimmed_leading "${_directive_args_raw}")
                        set(_directive_args_leading_trimmed "")
                        string(LENGTH "${_temp_args_trimmed_leading}" _args_leading_parse_len)
                        set(_args_leading_parse_idx 0)
                        set(_non_ws_found_in_args_leading FALSE)
                        while (_args_leading_parse_idx LESS _args_leading_parse_len)
                            string(SUBSTRING "${_temp_args_trimmed_leading}" ${_args_leading_parse_idx} 1 _a_p_char_lead)
                            if (NOT _non_ws_found_in_args_leading AND (_a_p_char_lead STREQUAL " " OR _a_p_char_lead STREQUAL "\t"))
                                # skip
                            else ()
                                set(_non_ws_found_in_args_leading TRUE)
                                string(APPEND _directive_args_leading_trimmed "${_a_p_char_lead}")
                            endif ()
                            math(EXPR _args_leading_parse_idx "${_args_leading_parse_idx} + 1")
                        endwhile ()

                        # Trim trailing whitespace from args (_directive_args_leading_trimmed)
                        set(_directive_args "${_directive_args_leading_trimmed}") # Start with leading trimmed
                        string(LENGTH "${_directive_args}" _args_trailing_len)
                        set(_trimmed_trailing_this_pass TRUE)
                        while(_trimmed_trailing_this_pass AND _args_trailing_len GREATER 0)
                            set(_trimmed_trailing_this_pass FALSE)
                            string(SUBSTRING "${_directive_args}" 0 1 _last_arg_char)
                            if (_last_arg_char STREQUAL " " OR _last_arg_char STREQUAL "\t")
                                math(EXPR _args_trailing_len "${_args_trailing_len} - 1")
                                if (_args_trailing_len LESS 0)
                                    set(_args_trailing_len 0)
                                endif()
                                string(SUBSTRING "${_directive_args}" 0 ${_args_trailing_len} _directive_args)
                                set(_trimmed_trailing_this_pass TRUE)
                                string(LENGTH "${_directive_args}" _args_trailing_len) # Re-evaluate
                            endif()
                        endwhile()
                    else () # No args, command is whole body
                        if (_directive_command STREQUAL "")
                            set(_directive_command "${_final_body_for_parse}") # Should be already set if no split
                        endif()
                        set(_directive_args "") # Ensure args is empty
                    endif ()

                    set(_directive_appended_specially FALSE)
                    _sh_check_is_implementation_directive("${_directive_command}" "${_directive_args}" "${IMPL_MACRO_NAME}" _is_impl_block_trigger_directive)

                    if (_is_impl_block_trigger_directive)
                        if (_impl_block_pp_level EQUAL -1)
                            set(_current_target "source")
                            set(_impl_block_pp_level ${_pp_level})
                        endif ()
                        math(EXPR _pp_level "${_pp_level} + 1")
                        if (_current_target STREQUAL "source")
                            string(APPEND _output_cxx_content "${_directive_full_raw_line}")
                        else ()
                            string(APPEND _output_h_content "${_directive_full_raw_line}")
                        endif ()
                        set(_directive_appended_specially TRUE)
                    elseif (_directive_command STREQUAL "if" OR _directive_command STREQUAL "ifdef" OR _directive_command STREQUAL "ifndef")
                        math(EXPR _pp_level "${_pp_level} + 1")
                    elseif (_directive_command STREQUAL "endif")
                        math(EXPR _pp_level "${_pp_level} - 1")
                        if (NOT _impl_block_pp_level EQUAL -1 AND _pp_level EQUAL _impl_block_pp_level)
                            string(APPEND _output_cxx_content "${_directive_full_raw_line}")
                            set(_current_target "header")
                            set(_impl_block_pp_level -1)
                            set(_directive_appended_specially TRUE)
                        endif ()
                    endif ()

                    if (NOT _directive_appended_specially)
                        if (_current_target STREQUAL "source")
                            string(APPEND _output_cxx_content "${_directive_full_raw_line}")
                        else ()
                            string(APPEND _output_h_content "${_directive_full_raw_line}")
                        endif ()
                    endif ()

                    set(_char_idx ${_directive_scan_idx})
                    set(_skip_default_char_idx_increment TRUE)
                else () # '#' was not at the logical start of a line
                    if (_current_target STREQUAL "source")
                        string(APPEND _output_cxx_content "${_cur_char}")
                    else ()
                        string(APPEND _output_h_content "${_cur_char}")
                    endif ()
                endif () # End if(_is_directive_on_line)
            else () # Normal character
                if (_cur_char STREQUAL "\n")
                    math(EXPR _line_start_idx "${_char_idx} + 1")
                endif ()
                if (_current_target STREQUAL "source")
                    string(APPEND _output_cxx_content "${_cur_char}")
                else ()
                    string(APPEND _output_h_content "${_cur_char}")
                endif ()
            endif () # End of main _cur_char type check
        endif () # End of _in_c_comment / _in_cpp_comment etc. block

        if (NOT _skip_default_char_idx_increment)
            math(EXPR _char_idx "${_char_idx} + ${_char_consumed_this_iteration}")
        endif ()
    endwhile ()

    file(WRITE "${OUTPUT_HEADER_FILE}" "${_output_h_content}")
    file(WRITE "${OUTPUT_SOURCE_FILE}" "${_output_cxx_content}")

    message(STATUS "Header splitting complete for ${INPUT_HEADER_FILE}.")
endfunction()

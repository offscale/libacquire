# Function to split header-only .h into separate header .h and source .c files
function(generate_header_and_source_from_header_only input_file output_header output_source)
    # limitations:
    # - expects a comment on endif, like `#endif /* LIBACQUIRE_IMPLEMENTATION */`
    # - only handles the first `LIBACQUIRE_IMPLEMENTATION` impl
    # - doesn't evaluate macros, so `!defined(LIBACQUIRE_IMPLEMENTATION)` will still move that block to .c file
    if (NOT EXISTS "${input_file}")
        message(FATAL_ERROR "Input file not found: ${input_file}")
    elseif (IS_DIRECTORY "${input_file}")
        message(FATAL_ERROR "Unexpected dir (expected file): ${input_file}")
    endif ()

    file(READ "${input_file}" content)
    string(LENGTH "${content}" content_len)
    math(EXPR content_len_minus_1 "${content_len} - 1")
    set(i 0)
    set(in_char OFF)
    set(in_str OFF)
    set(in_c_comment OFF)
    set(in_cpp_comment OFF)
    set(in_macro OFF)
    set(in_statement OFF)

    set(c_comment_start -1)
    set(c_comment_end -1)
    set(macro_begin_start -1)
    set(macro_begin_end -1)
    set(macro_finish_start -1)
    set(macro_finish_end -1)
    set(guard_start -1)

    set(guard_name "LIBACQUIRE_IMPLEMENTATION")

    set(prev_ch "")
    set(line "")
    set(line_starts_idx 0)
    set(clear_line OFF)

    set(end_guard_found OFF)

    while (i LESS content_len)
        string(SUBSTRING "${content}" ${i} 1 char)
        math(EXPR i_plus_1 "${i} + 1")

        if (in_char)
            if (char STREQUAL "'" AND NOT prev_ch STREQUAL "\\")
                set(in_char OFF)
            endif (char STREQUAL "'" AND NOT prev_ch STREQUAL "\\")
        elseif (in_str)
            if (char STREQUAL "\"" AND NOT prev_ch STREQUAL "\\")
                set(in_str OFF)
            endif (char STREQUAL "\"" AND NOT prev_ch STREQUAL "\\")
        elseif (in_c_comment)
            if ("${prev_ch}${char}" STREQUAL "*/")
                set(in_c_comment OFF)
            endif ("${prev_ch}${char}" STREQUAL "*/")
        elseif (in_cpp_comment)
            if (char STREQUAL "\n")
                set(in_cpp_comment OFF)
                set(clear_line ON)
                set(line_starts_idx ${i_plus_1})
            endif (char STREQUAL "\n")
        elseif (in_macro)
            if (char STREQUAL "\n" AND NOT prev_ch STREQUAL "\\")
                set(in_macro OFF)
                if (macro_finish_start EQUAL -1)
                    set(macro_begin_end ${i})
                    math(EXPR macro_begin_len "${macro_begin_end} - ${macro_begin_start}")
                    string(SUBSTRING "${content}" ${macro_begin_start} ${macro_begin_len} macro_begin)
                else ()
                    set(macro_finish_end ${i})
                    math(EXPR macro_finish_len "${macro_finish_end} - ${macro_finish_start}")
                    string(SUBSTRING "${content}" ${macro_finish_start} ${macro_finish_len} macro_finish)
                    if (macro_finish MATCHES "^[ \t]*#[ \t]*if.*${guard_name}")
                        set(macro_begin_start ${macro_finish_start})
                        set(macro_begin_end ${macro_finish_end})
                        set(macro_finish_start -1)
                        set(macro_finish_end -1)
                    elseif (macro_finish MATCHES "^[ \t]*#[ \t]*endif.*${guard_name}")
                        set(end_guard_found ON)
                        break()
                    endif ()
                endif ()
                set(clear_line ON)
                set(line_starts_idx ${i_plus_1})
            endif (char STREQUAL "\n" AND NOT prev_ch STREQUAL "\\")
        else ()
            if (NOT prev_ch STREQUAL "\\")
                if (char STREQUAL "'")
                    set(in_char ON)
                elseif (char STREQUAL "\"")
                    set(in_str ON)
                elseif ("${prev_ch}${char}" STREQUAL "/*")
                    set(in_c_comment ON)
                elseif ("${prev_ch}${char}" STREQUAL "//")
                    set(in_cpp_comment ON)
                elseif (char STREQUAL "\n")
                    set(clear_line ON)
                    set(line_starts_idx ${i_plus_1})
                else ()
                    if (char STREQUAL "#")
                        string(REGEX REPLACE "^[ \t\r]+" "" whitespace_free_line "${line}")
                        string(LENGTH "${whitespace_free_line}" whitespace_free_line_len)
                        if (whitespace_free_line_len EQUAL 0)
                            set(in_macro ON)
                            if (macro_begin_start EQUAL -1)
                                set(macro_begin_start ${i})
                            else ()
                                set(macro_finish_start ${i})
                            endif ()
                        endif ()
                    endif ()
                endif ()
            endif (NOT prev_ch STREQUAL "\\")
        endif ()

        set(line "${line}${char}")

        if (clear_line)
            set(line "")
            set(clear_line OFF)
        endif (clear_line)

        set(i ${i_plus_1})
        set(prev_ch "${char}")
    endwhile (i LESS content_len)

    file(WRITE "${output_header}" "${header_lines}")
    if (end_guard_found)
        string(LENGTH "${line}" line_len)
        math(EXPR impl_length "${macro_finish_end} - ${macro_begin_end} - ${line_len}")
        string(SUBSTRING "${content}" "${macro_begin_end}" "${impl_length}" impl_content)
        string(SUBSTRING "${content}" 0 "${macro_begin_start}" head_start)
        string(SUBSTRING "${content}" "${macro_finish_end}" -1 head_end)

        get_filename_component(header_only "${output_header}" NAME)
        file(WRITE "${output_header}" "${head_start}${head_end}")
        file(WRITE "${output_source}" "#include \"${header_only}\"\n\n${impl_content}")
    else ()
        file(WRITE "${output_header}" "${content}")
    endif ()
endfunction(generate_header_and_source_from_header_only input_file output_header output_source)

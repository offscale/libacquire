function(generate_header_and_source_from_header_only input_file output_header output_source)
    if (NOT EXISTS "${input_file}")
        message(FATAL_ERROR "Input file not found: ${input_file}")
    elseif (IS_DIRECTORY "${input_file}")
        message(FATAL_ERROR "Unexpected dir (expected file): ${input_file}")
    endif ()

    file(READ "${input_file}" content)
    string(LENGTH "${content}" content_len)
    math(EXPR content_len_minus_1 "${content_len} - 1")
    set(i 0)
    set(in_char OFF)
    set(in_str OFF)
    set(in_c_comment OFF)
    set(in_cpp_comment OFF)
    set(in_macro OFF)
    set(in_statement OFF)

    set(c_comment_start -1)
    set(c_comment_end -1)
    set(macro_begin_start -1)
    set(macro_begin_end -1)
    set(macro_finish_start -1)
    set(macro_finish_end -1)
    set(guard_start -1)

    # No need to check if in an `#if`, `#ifdef`, `#endif`
    # My convention starts with an `#if` | `#ifdef` with LIBACQUIRE_IMPLEMENTATION
    # â€¦and endswith an `#endif` with LIBACQUIRE_IMPLEMENTATION in its C-style comment
    set(guard_name "LIBACQUIRE_IMPLEMENTATION")

    set(prev_ch "")
    # roughly newline seperated, line-continuation can impact this though for multiline support
    # `line` can also have multiple statements like `char *s="foo";int a;\n`
    set(line "")
    set(line_starts_idx -1)
    set(clear_line OFF)

    while (i LESS content_len_minus_1)
        math(EXPR i_plus_1 "${i} + 1")
        string(SUBSTRING "${content}" ${i} 1 char)

        # Toggle the multiline and context changing vars
        if (in_char)
            if (char STREQUAL "'" AND NOT prev_ch STREQUAL "\\")
                set(in_char OFF)
            endif (char STREQUAL "'" AND NOT prev_ch STREQUAL "\\")
        elseif (in_str)
            if (char STREQUAL "'" AND NOT prev_ch STREQUAL "\\")
                set(line "${line}${char}")
                set(in_char OFF)
            endif (char STREQUAL "'" AND NOT prev_ch STREQUAL "\\")
        elseif (in_c_comment)
            if ("${prev_ch}${char}" STREQUAL "*/")
                set(in_c_comment OFF)
            endif ("${prev_ch}${char}" STREQUAL "*/")
        elseif (in_cpp_comment)
            if (char MATCHES "^[\n]+")
                set(in_cpp_comment OFF)
                set(line "")
                set(line_starts_idx ${i_plus_1})
                set(clear_line ON)
            endif (char MATCHES "^[\n]+")
        elseif (in_macro)
            if (char MATCHES "^[\n]+" AND NOT prev_ch STREQUAL "\\")
                set(in_macro OFF)
                if (macro_finish_start EQUAL -1)
                    set(macro_begin_end ${i})
                    math(EXPR macro_begin_len "${macro_begin_end} - ${macro_begin_start}")
                    string(SUBSTRING "${content}" "${macro_begin_start}" "${macro_begin_len}" macro_begin)
                    message(STATUS "[${input_file}] START is \"${macro_begin}\"")
                else ()
                    set(macro_finish_end ${i})
                    math(EXPR macro_finish_len "${macro_finish_end} - ${macro_finish_start}")
                    string(SUBSTRING "${content}" "${macro_finish_start}" "${macro_finish_len}" macro_finish)
                    message(STATUS "[${input_file}] END is ${macro_finish}")
                endif ()
                message(STATUS "[in_macro] line = \"${line}\"")
                set(line "")
                set(line_starts_idx "${i_plus_1}")
                set(clear_line ON)
            endif (char MATCHES "^[\n]+" AND NOT prev_ch STREQUAL "\\")
        else ()
            if (NOT prev_ch STREQUAL "\\")
                if (char STREQUAL "'")
                    set(in_char ON)
                elseif (char STREQUAL "\"")
                    set(in_str ON)
                elseif ("${prev_ch}${char}" STREQUAL "/*")
                    set(in_c_comment ON)
                elseif ("${prev_ch}${char}" STREQUAL "//")
                    set(in_cpp_comment ON)
                elseif (char MATCHES "^[\n]+")
                    message(STATUS "[newline, prev_ch='${prev_ch}'] line = \"${line}\"")
                    set(line "")
                    set(line_starts_idx "${i_plus_1}")
                    set(clear_line ON)
                else ()
                    if (char STREQUAL "#")
                        string(REGEX REPLACE "^[ \t\r]+" "" whitespace_free_line "${line}")
                        string(LENGTH "${whitespace_free_line}" whitespace_free_line_len)
                        if (whitespace_free_line_len EQUAL 0)
                            set(in_macro ON)
                            if (macro_begin_start EQUAL -1)
                                set(macro_begin_start ${i})
                            else ()
                                set(macro_finish_start ${i})
                            endif ()
                        endif (whitespace_free_line_len EQUAL 0)
                    else ()
                        #message(STATUS "unimportant = '${char}'")
                    endif (char STREQUAL "#")
                endif ()
            endif (NOT prev_ch STREQUAL "\\")
        endif ()

        if (clear_line)
          set(clear_line OFF)
        else ()
          set(line "${line}${char}")
        endif ()
        set(i ${i_plus_1})
        set(prev_ch "${char}")
    endwhile (i LESS content_len_minus_1)

    message(STATUS "macro_begin_start is ${macro_begin_start} for ${input_file}")
    message(STATUS "macro_finish_start is ${macro_finish_start} for ${input_file}")


    # Write outputs
    file(WRITE "${output_header}" "${header_lines}")
    if (NOT "${source_lines}" STREQUAL "")
        get_filename_component(header_only "${output_header}" NAME)
        # Include header in source
        file(WRITE "${output_source}" "#include \"${header_only}\"\n\n${source_lines}")
    else ()
        # No impl block
        file(WRITE "${output_source}" "")
    endif ()
endfunction(generate_header_and_source_from_header_only input_file output_header output_source)

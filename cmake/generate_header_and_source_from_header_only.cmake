# Function to split header-only .h file into separate header .h and source .c files
function(generate_header_and_source_from_header_only guard_name input_file output_header output_source)
    # limitations:
    # - expects a comment on endif, like `#endif /* LIBACQUIRE_IMPLEMENTATION */`
    # - only handles the first `LIBACQUIRE_IMPLEMENTATION` impl
    # - doesn't evaluate macros, so `!defined(LIBACQUIRE_IMPLEMENTATION)` will still move that block to .c file

    # implementation
    # - superior to basic find, as it parses string literals, char literals, comments (both kinds)

    if (NOT EXISTS "${input_file}")
        message(FATAL_ERROR "Input file not found: ${input_file}")
    elseif (IS_DIRECTORY "${input_file}")
        message(FATAL_ERROR "Unexpected dir (expected file): ${input_file}")
    endif ()

    file(READ "${input_file}" content)
    string(LENGTH "${content}" content_len)
    math(EXPR content_len_minus_1 "${content_len} - 1")
    set(i 0)
    set(in_char OFF)
    set(in_str OFF)
    set(in_c_comment OFF)
    set(in_cpp_comment OFF)
    set(in_macro OFF)
    set(in_statement OFF)

    set(c_comment_start -1)
    set(c_comment_end -1)
    set(macro_begin_start -1)
    set(macro_begin_end -1)
    set(macro_finish_start -1)
    set(macro_finish_end -1)
    set(guard_start -1)

    set(prev_ch "")
    set(line "")
    set(line_starts_idx 0)
    set(clear_line OFF)

    set(end_guard_found OFF)

    while (i LESS content_len)
        string(SUBSTRING "${content}" ${i} 1 char)
        math(EXPR i_plus_1 "${i} + 1")

        if (in_char AND char STREQUAL "'" AND NOT prev_ch STREQUAL "\\")
            set(in_char OFF)
        elseif (in_str AND char STREQUAL "\"" AND NOT prev_ch STREQUAL "\\")
            set(in_str OFF)
        elseif (in_c_comment AND "${prev_ch}${char}" STREQUAL "*/")
            message(STATUS "C comment finished, line ${line}")
            set(in_c_comment OFF)
        elseif (in_cpp_comment AND char STREQUAL "\n")
            set(in_cpp_comment OFF)
            set(clear_line ON)
            message(STATUS "[newline] \"${line}\"")
            set(line_starts_idx ${i_plus_1})
        elseif (in_macro AND char STREQUAL "\n" AND NOT prev_ch STREQUAL "\\")
            set(in_macro OFF)
            if (macro_finish_start EQUAL -1)
                set(macro_begin_end ${i})
                math(EXPR macro_begin_len "${macro_begin_end} - ${macro_begin_start}")
                string(SUBSTRING "${content}" ${macro_begin_start} ${macro_begin_len} macro_begin)
            else ()
                set(macro_finish_end ${i})
                math(EXPR macro_finish_len "${macro_finish_end} - ${macro_finish_start}")
                string(SUBSTRING "${content}" ${macro_finish_start} ${macro_finish_len} macro_finish)
                if (macro_finish MATCHES ".*${guard_name}.*")
                    message(STATUS "Analysing \"${line}\"")
                    if (macro_finish MATCHES "^[ \t]*#[ \t]*(ifdef[ \t]+${guard_name}|if[ \t]+.*)")
                        set(macro_begin_start ${macro_finish_start})
                        set(macro_begin_end ${macro_finish_end})
                        set(macro_finish_start -1)
                        set(macro_finish_end -1)
                    elseif (macro_finish MATCHES "^[ \t]*#[ \t]*endif.*")
                        set(end_guard_found ON)
                        string(LENGTH "${macro_finish}" endif_len)
                        set(endif_len ${endif_len})
                        break()
                    else ()
                        message(STATUS "Odd Unrelated macro: ${line}")
                    endif ()
                else ()
                    message(STATUS "Unrelated macro: ${line}")
                endif ()
            endif ()
            set(clear_line ON)
            set(line_starts_idx ${i_plus_1})
        else ()
            if (prev_ch STREQUAL "\\")
                set(i ${i_plus_1})
                set(prev_ch "${char}")
                continue()
            elseif (char STREQUAL "'")
                set(in_char ON)
            elseif (char STREQUAL "\"")
                set(in_str ON)
            elseif ("${prev_ch}${char}" STREQUAL "/*")
                message(STATUS "C comment started, line ${line}")
                set(in_c_comment ON)
            elseif ("${prev_ch}${char}" STREQUAL "//")
                set(in_cpp_comment ON)
            elseif (char STREQUAL "\n")
                set(clear_line ON)
                set(line_starts_idx ${i_plus_1})
            elseif (char STREQUAL "#" AND (line STREQUAL "" OR line MATCHES "^[ \t\r]+#+"))
                set(in_macro ON)
                if (macro_begin_start EQUAL -1)
                    set(macro_begin_start ${i})
                else ()
                    set(macro_finish_start ${i})
                endif ()
                math(EXPR i_plus_12 "${i} + 12")
                if (i_plus_12 LESS content_len)
                    string(SUBSTRING "${content}" ${i} 12 macro_first_12_chars)
                    if (macro_first_12_chars MATCHES "^[ \t\r]*#[ \t\r]*endif[ \t\r]*\\/\\*")
                        # read until end of comment, even if it has new lines and \
                        # len("#endif /*") == 9
                        set(macro_finish_start ${i})
                        set(macro_finish_end -1)
                        math(EXPR j "${i} + 9")
                        math(EXPR prev_j "${i} + 8")
                        while (j LESS content_len)
                            string(SUBSTRING "${content}" ${prev_j} 2 this_and_prev)
                            if (this_and_prev STREQUAL "*/")
                                math(EXPR j "${j} + 1")
                                set(macro_finish_end ${j})
                                break()
                            endif (this_and_prev STREQUAL "*/")
                            set(prev_j "${j}")
                            math(EXPR j "${j} + 1")
                        endwhile (j LESS content_len)
                        if (NOT macro_finish_end EQUAL -1)
                            math(EXPR macro_finish_len "${macro_finish_end} - ${macro_finish_start}")
                            string(SUBSTRING "${content}" ${macro_finish_start} ${macro_finish_len} macro_finish)

                            if (macro_finish MATCHES ".*${guard_name}.*")
                                message(STATUS "[matches] macro_finish \"${macro_finish}\"")
                                set(end_guard_found ON)
                                break()
                            else ()
                                message(STATUS "[nomatch] macro_finish \"${macro_finish}\"")
                            endif ()
                        endif (NOT macro_finish_end EQUAL -1)
                    elseif (macro_first_12_chars MATCHES "^[ \t]*#[ \t]*(ifdef|if)[ \t]+.*")
                        math(EXPR j "${i} + 3")
                        math(EXPR prev_j "${i} + 2")
                        set(in_c_comment0 OFF)
                        math(EXPR j "${i} + 9")
                        math(EXPR prev_j "${i} + 8")
                        while (j LESS content_len)
                            string(SUBSTRING "${content}" ${prev_j} 1 the_prev_char)
                            string(SUBSTRING "${content}" ${j} 1 this_char)
                            if (this_char STREQUAL "\n" AND NOT the_prev_char STREQUAL "\\")
                                math(EXPR len "${j} - ${i}")
                                string(SUBSTRING "${content}" ${i} ${len} macro_start)
                                message(STATUS "content[the_prev_char = \"${the_prev_char}\",${i}:${j}] = \"${macro_start}\"")
                                if (macro_start MATCHES ".*${guard_name}.*")
                                    set(macro_begin_start ${i})
                                    set(macro_begin_end ${j})
                                    break()
                                endif (macro_start MATCHES ".*${guard_name}.*")
                            endif (this_char STREQUAL "\n" AND NOT the_prev_char STREQUAL "\\")

                            set(prev_j "${j}")
                            math(EXPR j "${j} + 1")
                        endwhile (j LESS content_len)
                    endif ()
                endif (i_plus_12 LESS content_len)
            endif ()

            set(line "${line}${char}")

            if (clear_line)
                set(line "")
                set(clear_line OFF)
            endif (clear_line)

            set(i ${i_plus_1})
            set(prev_ch "${char}")
        endif ()
    endwhile (i LESS content_len)

    file(WRITE "${output_header}" "${header_lines}")
    if (end_guard_found)
        #string(LENGTH "${line}" line_len)
        #math(EXPR impl_length "${macro_finish_end} - ${macro_begin_end} - ${line_len}")
        #set(impl_length "${line_len}")
        math(EXPR impl_length "${macro_finish_end} - ${macro_begin_end}")
        string(SUBSTRING "${content}" "${macro_begin_end}" "${impl_length}" impl_content)

        # Remove the `#endif` line
        if (DEFINED endif_len)
            string(LENGTH "${impl_content}" impl_content_len)
            math(EXPR trimmed_len "${impl_content_len} - ${endif_len}")
            if (trimmed_len LESS 0)
                set(trimmed_len 0)
            endif ()
            string(SUBSTRING "${impl_content}" 0 "${trimmed_len}" impl_content)
        else ()
            string(FIND "${impl_content}" "\n" last_nl REVERSE)
            string(SUBSTRING "${impl_content}" 0 "${last_nl}" impl_content)
        endif ()

        string(SUBSTRING "${content}" 0 "${macro_begin_start}" head_start)
        string(SUBSTRING "${content}" "${macro_finish_end}" -1 head_end)

        get_filename_component(header_only "${output_header}" NAME)
        file(WRITE "${output_header}" "${head_start}${head_end}")
        file(WRITE "${output_source}" "#include \"${header_only}\"\n\n${impl_content}")
    else ()
        file(WRITE "${output_header}" "${content}")
    endif ()
endfunction(generate_header_and_source_from_header_only guard_name input_file output_header output_source)
